use Sparky::JobApi;
use SparkyCI;

class Pipeline does Sparky::JobApi::Role {

  has Str $.cpu = tags()<cpu> || "2";
  has Str $.max = tags()<max> || "5";
  has Str $.mem = tags()<mem> || "7";
  has Str $.num = tags()<num> || "0";
  has Str $.project = tags()<project> || "";
  has Str $.scm = tags()<scm> || "";
  has Str $.notify-project = tags()<notify-project> || "";;
  has Str $.notify-job = tags()<notify-job> || "";;

  method stage-run-container {

    bash qq:to/HERE/, %( description => "az container create" );
      #set -x 
      az container create -g sparky2 \\
        --name spk-0{$.num} \\
        --image melezhik/sparky-fastspec:v10 \\
        --cpu {$.cpu} --memory {$.mem} \\
        --secure-environment-variables SPARKY_API_TOKEN={%*ENV<SPARKY_API_TOKEN>} \\
        WORKER="{$.num}" \\
        SPARKY_TIMEOUT=5 \\
        SPARKY_PROJECT="raku" \\
        GIT_URL="https://github.com/melezhik/sparkyci.git" \\
        NOTIFY_PROJECT={self.notify-project} \\
        NOTIFY_JOB={self.notify-job} \\
        NOTIFY_API=https://sparrowhub.io:4000 -o table
    HERE

    my $j = self.new-job: :workers<4>;

    $j.queue({
      description => "run az container job #{$.num}",
      tags => %(
        stage => "run-container-job",
        num => $.num,
      ),
    });

  }


  method stage-run-container-job {

    bash qq:to/HERE/, %( description => "run sparky job" );
      az container exec -g sparky2 --name spk-0{$.num} \\
      --exec-command "curl -fs -d '' --retry-delay 10 --retry-connrefused --retry 10 -X POST 127.0.0.1:4000/build/project/container" \\
      -o table
    HERE

  }

  method stage-main {

    my @cjobs;
    my @njobs;

    say "configuration: cpu: {$.cpu} | mem: {$.mem} | vms: {$.max}";

    for 1 .. $.max.Int -> $i {

      my $cj = self.new-job: :workers<4>;

      my $nj = self.new-job: :project<raku.notify>, :job-id($cj.info()<job-id>);

      @cjobs.push: $cj;

      @njobs.push: $nj;

      $cj.queue({
        description => "run az container #{$i}",
        tags => %(
          stage => "run-container",
          cpu => $.cpu,
          mem => $.mem,
          num => $i,
          max => $.max,
          project => $.project,
          notify-job => $cj.info()<job-id>,
          notify-project => "raku.notify",
        ),
      });

    }

    # wait containers jobs
    my $s = self.wait-jobs(@cjobs); 

    # wait notify jobs
    my $s2 = self.wait-jobs(@njobs); 

    # remove containers
    say "clean up containers just in case ...";

    for 1 .. $.max.Int -> $i {

      bash "az container delete -g sparky2 --name spk-0{$i} -y -o table || echo", %(
        description => "delete container";
      );

    }

    my $time = now - INIT now;

    say "$time sec passed";

    say "cost: \$", (0.0000013**($.mem.Int)*$time*($.max.Int) + 0.0000113*($.cpu.Int)*$time*($.max,Int));

    my $state = $s2<OK> ?? 1 !! ( $s2<TIMEOUT> ?? -1 !! -2 );

    my $desc = $.scm;

    my $job-id = tags()<SPARKY_JOB_ID>;

    my $project = $.project;

    insert-build :$state, :$project, :$desc, :$job-id;

    die if $s<FAIL> or $s<TIMEOUT>;

    die if $s2<FAIL> or $s2<TIMEOUT>;

  }

}

Pipeline.new.run;  
