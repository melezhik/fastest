use Sparky::JobApi;
use SparkyCI;
use JSON::Tiny;

class Pipeline does Sparky::JobApi::Role {

  has Str $.cpu = tags()<cpu> || "2";
  has Str $.mem = tags()<mem> || "7";
  has Str $.project = tags()<project> || tags()<SPARKY_PROJECT> || "";
  has Str $.worker = tags()<worker> || "spk-" ~ (("a" .. "z").pick(10).join("")); 
  has Str $.scm = tags()<scm> || tags()<SCM_URL> || "";
  has Str $.notify-project = tags()<notify-project> || "";
  has Str $.notify-job = tags()<notify-job> || "";
  has Str $.git-sha = tags<SCM_BRANCH> || tags<git-sha> || "";

  method stage-run-container {

    say "run az container, scm: {$.scm}";

    bash qq:to/HERE/, %( description => "az container create" );
      #set -x 
      az container create -g sparky2 \\
        --name {$.worker} \\
        --image melezhik/sparky-fastspec:v10 \\
        --cpu {$.cpu} --memory {$.mem} \\
        --secure-environment-variables SPARKY_API_TOKEN={%*ENV<SPARKY_API_TOKEN>} \\
        SPARKY_TIMEOUT=5 \\
        SPARKY_PROJECT="raku" \\
        SCM={$.scm} \\
        GIT_SHA="{$.git-sha}" \\
        GIT_URL="https://github.com/melezhik/sparkyci.git" \\
        WORKER={$.worker} \\
        NOTIFY_PROJECT={self.notify-project} \\
        NOTIFY_JOB={self.notify-job} \\
        NOTIFY_API=https://sparrowhub.io:4000 -o table
    HERE

    my $j = self.new-job: :project<sparkyci.run.job>;

    $j.queue({
      description => "run az container job",
      tags => %(
        stage => "run-container-job",
        worker => $.worker,
      ),
    });

  }


  method stage-run-container-job {

    bash qq:to/HERE/, %( description => "run sparky job" );
      az container exec -g sparky2 --name {$.worker} \\
      --exec-command "curl -fs -d '' --retry-delay 10 --retry-connrefused --retry 10 -X POST 127.0.0.1:4000/build/project/container" \\
      -o table
    HERE

  }

  method stage-main {

    say "configuration: cpu: {$.cpu} | mem: {$.mem}";


      my $cj = self.new-job: :project<sparkyci.run.container>;

      my $nj = self.new-job: :project<raku.notify>, :job-id($cj.info()<job-id>);

      $cj.queue({
        description => "{$.project} - run az container",
        tags => %(
          stage => "run-container",
          cpu => $.cpu,
          mem => $.mem,
          project => $.project,
          notify-job => $cj.info()<job-id>,
          notify-project => "raku.notify",
          scm => $.scm,
          git-sha => $.git-sha,
          worker => $.worker,
        ),
      });


    # wait containers jobs
    my $s = self.wait-job($cj); 

    # wait notify jobs
    my $s2 = self.wait-job($nj, %( timeout => 800 )); 

    # remove containers
    say "clean up containers just in case ...";

    bash "az container delete -g sparky2 --name {$.worker} -y -o table || echo", %(
      description => "delete container";
    );

    my $time = now - INIT now;

    say "$time sec passed";

    say "cost: \$", (0.0000013**($.mem.Int)*$time*1 + 0.0000113*($.cpu.Int)*$time*1);

    my $state = $s2<OK> ?? 1 !! ( $s2<TIMEOUT> ?? -1 !! -2 );

    my $desc = $.scm;

    my $job-id = tags()<SPARKY_JOB_ID>;

    my $project = $.project;

    say "generate sparkyci build ...";

    my $bid = insert-build :$state, :$project, :$desc, :$job-id;

    say "bid: $bid";

    mkdir "{sparkyci-root()}/data/{$bid}";

    my $nj-stash = $nj.get-stash;

    "{sparkyci-root()}/data/{$bid}/log.txt".IO.spurt($nj-stash<log>||"");

    "{sparkyci-root()}/data/{$bid}/data.json".IO.spurt(to-json(%(
      date => "{DateTime.now}",
      state => $state,
      project => $project,
      desc => $desc,
      job-id => $job-id,
      id => $bid,
      test-coverage-html => $nj-stash<test-coverage-html> || "",
      log => $nj-stash<log> || "",
      raku-env => $nj-stash<raku-env> || {}, 
    )));


    say $s.perl;

    say $s2.perl;

    die if $s<FAIL> or $s<TIMEOUT>;

    die if $s2<FAIL> or $s2<TIMEOUT>;

  }

}

Pipeline.new.run;  
