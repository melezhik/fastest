use Sparky::JobApi;
use HTTP::Tiny;

class Pipeline does Sparky::JobApi::Role {

  has Str $.project = %*ENV<PROJECT> || "";
  has Str $.worker = %*ENV<WORKER> || tags()<worker> || "";
  has Str $.scm = %*ENV<SCM> || "";
  has Str $.git-sha = %*ENV<GIT_SHA> || "";
  has Str $.scm-dir = tags()<scm-dir> || "";
  has Str $.notify-api = %*ENV<NOTIFY_API> || "";
  has Str $.notify-project = %*ENV<NOTIFY_PROJECT> || "";
  has Str $.notify-job = %*ENV<NOTIFY_JOB> || "";

  method stage-test {

      say "scm: {$.scm}";
      say "scm-dir: {$.scm-dir}";
      say "git-sha: {$.git-sha}";

      zef "App::RaCoCo", %(
          description => "install App::RaCoCo",
          notest => True 
      );

      zef "App::Prove6", %(
          description => "install prove6",
          notest => True
      );

      bash "zef install --deps-only --/test . 2>&1", %(
        cwd => $.scm-dir,
        description => "install deps"
      );
    
      bash "racoco -l --html 2>&1", %(
        cwd => $.scm-dir,
        description => "run tests"
      );

      my $j = self.new-job: :mine(True);

      $j.put-stash({
        test-coverage-html => ("{$.scm-dir}/.racoco/report.html".IO ~~ :e ?? "{$.scm-dir}/.racoco/report.html".IO.slurp !! ""),
      });
  }


  method stage-main {

      say "run raku build for scm: {$.scm}";

      directory "scm";

      git-scm $.scm, %(
        to => "scm",
        branch => $.git-sha,
      );

      my $git-data = task-run "git data", "git-commit-data", %(
        dir => "{$*CWD}/scm",
      );

      my $j = self.new-job;

      $j.queue({
        description => "test",
        tags => %(
          stage => "test",
          scm-dir => "{$*CWD}/scm"
        ),
      });


      my $s = self.wait-job($j);

      my $nj = self.new-job: 
        :api($.notify-api), 
        :project($.notify-project), 
        :job-id($.notify-job);


      my %j = $j.info;

      my $r = HTTP::Tiny.get: "http://127.0.0.1:4000/report/raw/{%j<project>}/{%j<job-id>}";

      my $log = $r<content> ?? $r<content>.decode !! '';

      my $test-coverage-html = $j.get-stash()<test-coverage-html> || ""; 

      my $raku-env = task-run "dump info", "raku-env-info";

      if $s<OK> {
        $nj.put-stash({ 
          status => "OK", 
          log => $log, 
          test-coverage-html => $test-coverage-html,
          raku-env => $raku-env,
          git-data => $git-data,
        });
      } else {
        $nj.put-stash({ 
          status => "FAIL", 
          log => $log,  
          test-coverage-html => $test-coverage-html,
          raku-env => $raku-env,
          git-data => $git-data,
        });
      }

      $nj.queue({
        description => "{$.project} - build report",
        tags => %(
          stage => "notify",
          worker => $.worker,
        ),
      });
      
  }

  method stage-notify {

    my $nj = self.new-job: :mine(True);

    my $report = $nj.get-stash();

    say "=========================";

    say "status: ", $report<status>;

    say "log: ", $report<log>;

    bash "az container delete -g sparky2 --name {$.worker} -y -o table || echo", %(
      description => "delete container";
    );

    die unless $report<status> eq "OK";

  }

}

Pipeline.new.run;  
